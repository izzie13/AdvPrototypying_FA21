<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main Page</title>
</head>
<html>
<head>
<style>
* {
  box-sizing: border-box;
}

.column {
  float: left;
  width: 33.33%;
  padding: 5px;
}

/* Clearfix (clear floats) */
.row::after {
  content: "";
  clear: both;
  display: table;
}
</style>
</head>
<body>

<h1>Izzie Chen's Adv. Prototyping Projects</h1>
    
<h2 style="background-color:powderblue;">Week 1: Natural System</h2>

<img src="UML Diagram.jpg" 
    width="600" 
    height= auto/> 
<img src="workflow.jpg"
    width="600" 
    height= auto/>

<h2 style="background-color:powderblue;">Week 2: Natural System </h2>
<h3>from last Week, I added more components into the system to make the porject more close to the reality and more engaged. </h3>
<img src="UML Diagram F.jpg" 
    width= auto 
    height= "800"/> 
<img src="Flow Diagram F.jpg"
    width= auto 
    height= "800"/>
<p>I think it is really interesting to see how the ant lives in the human city, and I beg everyone has observed how ants move their food back to their home and how they around the walking people and obstacles either on the street or at the park.<br> 
    So I decide to program that scene in processing as my first project. At first, I imagined that there will be an ant trying to avoid being stepped on by people, and if it got stepped, the game is over. In order to make this process more close to<br> 
    the reality and to be fun to play with, I added the food and anthill components and add a carry-food task. While ant is keeping away from human to step it, ant also need to find the food and bring back food to the anthill and collect as much<br> 
    food as it can. Since I suddenly have 4 components in my system (ant, food, foot, anthill) and 3 of them are moving components, it is hard for me to make the 3 move in the certain pattern (food and the human follow the ant). During my research,<br> 
    I found the easing function on the Processing’s preference page, and I used easing a lot to make the food and the human follow after and created a pattern that the ant would carry the food and try to get away from the human by simply adjust the<br> 
    easing value. For the future, I would like to change the human’s walking path to be unpredictable. The walking path can be random as a bouncing ball inside of the window.<p>
    <br> 
    <h3>Coding Examples</h3>
    <br> 
    <p style="background-color:beige;"> Hill anthill;<br>
        Ant steve;<br>
        Foot step;<br>
        Food apple;<br>
        void setup() {<br>
          size(800, 800);<br>
          steve = new Ant();<br>
          step = new Foot();<br>
          apple = new Food();<br>
          anthill = new Hill();<br>
        }<br>
        void draw() {<br>
          background (163, 163, 163);<br>
          anthill.score();<br>
          anthill.display();<br>
          apple.display();<br>
          steve.move();<br>
          steve.catchFood(apple.x, apple.y);<br>
          steve.display();<br>
          step.move(steve.x, steve.y);<br>
          step.display();<br>
          if (steve.carrying) {<br>
            apple.move(steve.x, steve.y);<br>
          }<br>
          if (dist(apple.x, apple.y, anthill.x, anthill.y) <=anthill.size) {<br>
            steve.carrying = false;<br>
            anthill.score += 1;<br>
            step.reduce();<br>
            apple = new Food();<br>
          }<br>
          if (dist(steve.x, steve.y, step.x+step.size/2, step.y+step.size/2) <= step.size/2) {<br>
            step.enlarge();<br>
          }<br>
          if (step.size >= 150) {<br>
            fill(256, 256, 256);<br>
            text("Game Over", width/2 - 50, height/2);<br>
            stop();<br>
          }<br>
        }<br>
        class Ant {<br>
            float x, y;<br>
            float size;<br>
            boolean carrying;<br>
            Ant() {<br>
              x = width/2;<br>
              y = height/2;<br>
              size = 40;<br>
              carrying = false;<br>
            }<br>
            <br>
            void display() {<br>
              fill(0, 0, 0);<br>
              circle (x, y, 18);<br>
              circle (x+9, y+9, 15);<br>
              circle (x+18, y+18, 18);<br>
            }<br>
            void catchFood(float foodX, float foodY) {<br>
              if (dist(x, y, foodX, foodY) <= size) {<br>
                carrying = true;<br>
              }<br>
            }<br>
            void move() {<br>
              x = mouseX;<br>
              y = mouseY;<br>
            }<br>
          }<br>
          <br>
          class Food {<br>
            float x, y;<br>
            float easing;<br>
            Food() {<br>
              x = random(width);<br>
              y = random(height);<br>
              easing = 0.95;<br>
            }<br>
            void display() {<br>
              noStroke();<br>
              fill(0, 255, 0);<br>
              circle (x, y, 24);<br>
            }<br>
            void move(float targetX, float targetY) {<br>
              float dx = targetX - x;<br>
              x += dx * easing;<br>
              float dy = targetY - y;<br>
              y += dy * easing;<br>
            }<br>
          }<br>
          <br>
          class Foot {<br>
            float x, y;<br>
            float size;<br>
            float easing;<br>
            Foot() {<br>
              x = width/2;<br>
              y = height/2;<br>
              size = 80;<br>
              easing = 0.05;<br>
            }<br>
            <br>
            void display() {<br>
              noFill();<br>
              stroke(255, 255, 255);<br>
              square(x, y, size);<br>
            }<br>
            void move(float targetX, float targetY) {<br>
              float dx = targetX - x;<br>
              x += dx * easing;<br>
              float dy = targetY - y;<br>
              //footstep variables<br>
              y += dy * easing;<br>
            }<br>
            void enlarge() {<br>
              size += 0.9;<br>
            }<br>
            void reduce() {<br>
              size -= 0.9;<br>
            }<br>
          }<br>
          class Hill {<br>
            float x, y;<br>
            float size;<br>
            int score;<br>
            Hill() {<br>
              x = 607;<br>
              y = 640;<br>
              size = 60;<br>
              score = 0;<br>
            }<br>
            void display() {<br>
              fill(255, 255, 255);<br>
              noStroke();<br>
              triangle(550, 700, 632, 580, 714, 700);<br>
            }<br>
            void score() {<br>
              fill(255, 255, 0);<br>
              text(score, 430, 50);<br>
              text("score:",350,50); <br>   
              textSize(30);<br>
            }<br>
          }<br>
    </p>


    <div class="row">
        <div class="column">
          <img src="GameAntEscaping.png" style="width:70%">
          <figcaption>The image above shows first start the game, you need to use cursor to control the ant from a square which represents the human's footstep.</figcaption>
        </div>
        <div class="column">
          <img src="AntCatchFood.png" style="width:70%">
          <figcaption>The image above shows when the ant has catched the food (green dot), you need to use cursor to control the ant with the food escape from the square's chase and look for the anthill.</figcaption>
        </div>
        <div class="column">
          <img src="BacktoHill.png" style="width:70%">
          <figcaption>The image above shows when the ant bring the food back to anthill (white triangle), there would be new food generated and add 1 score to the scoreboard shows on the middle top.</figcaption>
        </div>
        <div class="column">
            <img src="GameOver.png" style="width:70%">
            <figcaption>The image above shows when the foot has stepped on the ant, it would enlarge the size of the step, and when the step size reach to 150 pixels, the game is over.</figcaption>
          </div>
      </div>

<h2 style="background-color:powderblue;"> Week 3: Reading Response </h2>
<h3>Stephanie Houde and Charles Hill, What do Prototypes Prototype? </h3>
<p><span style="font-weight:bold">Quote 1:</span> "In fact, these three prototypes were developed almost in parallel. They were built by different design team members during the early stages of the project. No single prototype could have<br> 
    represented the design of the future artifact at that time. The evolving design was too fuzzy—existing mainly as a shared concept in the minds of the designers. There were also too many open and<br>  
    interdependent questions in every design dimension: role, look and feel, implementation."<br>
    Note: I think developing 3 prototypes as the same time is an essential way to achieve the final design goal. Since working separately would not limit the creativity and possibility of the design. For example, while designers defining the<br>   
    look and feel prototype, they would not consider about the implementation at this stage, and no-one would come to them and tell them this could not work, which make the prototypes close to the original design purpose. In this way, it is<br>   
    also convenient to organize and clarify the issues among 3 prototypes  in the final stage.<br>
    <br>
    <span style="font-weight:bold">Quote 2:</span> "They simulate what it would be like to look at and interact with, without necessarily investigating the role it would play in the user’s life or how it would be made to work."<br>
    Note: I believe how user would use and when they would use it should also be considered while developing the look and feel prototype. For example, if we are designing a product for elders or disabled, designer should keep in mind<br>   
    product’s role in developing the look and feel prototype. How could they interact with the product? How would they use the product? How often do they use? Where do they use at? Those questions should be answered while creating<br>   
    the look and feel of the design.<br>
    <br>
    <span style="font-weight:bold">Quote 3:</span> "Designers make implementation prototypes as experiments for themselves and the design team, to demonstrate to their organization the technical feasibility of the artifact, and to<br>   
    get feedback from users on performance issues."<br>
    Note: Once the designer has determined the time they plan to launch the product, or the time period the product would last in the future, the implementation prototype would not be that necessary. Since, if the prudct is designed<br>   
    to launch after 20 years from now, the product can be really conceptual, even some features and functions cannot be supported based on nowadays technology, but there would be a time in the future that the new inventions would<br>   
    help to build the product. The implementation prototype cannot only be tested by now but also can be considered in the future.</p>

</html>