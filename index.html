<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Izzie's Blog</title>
        <link rel="stylesheet" href="style.css">
        <a href = ""></a>
    </head>
<html>
    <head>
    <style>
        * {
        box-sizing: border-box;
        }

        .column {
        float: left;
        width: 25%;
        padding: 3px;
        }

        /* Clearfix (clear floats) */
        .row::after {
        content: "";
        clear: both;
        display: table;
        }
    </style>
    </head>
<body>
    <ul>
        <li><a href="#">Home</a></li>
        <li><a href="#">Natural System</a></li>
        <li><a href="#">Control System</a></li>
        <li><a href="#">Project 3</a></li>
        <li><a href="#">Project 4</a></li>
        <li><a href="#">Reading Response</a></li>

    </ul>

<h1><fontface="verdana" size="20px" >Izzie Chen's Adv. Prototyping Projects</fontface></h1>
    


<h2 style="background-color:powderblue;">Project 1: Natural System </h2>

<img src="UML Diagram F.jpg" 
    width= auto 
    height= "800"/> 
<img src="Flow Diagram F.jpg"
    width= auto 
    height= "800"/>
    <br> 
<h3> Summary</h3>
<br>
<p class="paragraph">I think it is really interesting to see how the ant lives in the human city, and I beg everyone has observed how ants move their food back to their home and how they around the walking people and obstacles either on the street or at the park.<br> 
    So I decide to program that scene in processing as my first project. At first, I imagined that there will be an ant trying to avoid being stepped on by people, and if it got stepped, the game is over. In order to make this process more close to<br> 
    the reality and to be fun to play with, I added the food and anthill components and add a carry-food task. While ant is keeping away from human to step it, ant also need to find the food and bring back food to the anthill and collect as much<br> 
    food as it can. Since I suddenly have 4 components in my system (ant, food, foot, anthill) and 3 of them are moving components, it is hard for me to make the 3 move in the certain pattern (food and the human follow the ant). During my research,<br> 
    I found the easing function on the Processing’s preference page, and I used easing a lot to make the food and the human follow after and created a pattern that the ant would carry the food and try to get away from the human by simply adjust the<br> 
    easing value. For the future, I would like to change the human’s walking path to be unpredictable. The walking path can be random as a bouncing ball inside of the window.<p>
    <br> 
    <h3>Code Example</h3>
    <pre><code>
        Hill anthill;
        Ant steve;
        Foot step;
        Food apple;
        void setup() {
          size(800, 800);
          steve = new Ant();
          step = new Foot();
          apple = new Food();
          anthill = new Hill();
        }
        void draw() {
          background (163, 163, 163);
          anthill.score();
          anthill.display();
          apple.display();
          steve.move();
          steve.catchFood(apple.x, apple.y);
          steve.display();
          step.move(steve.x, steve.y);
          step.display();
          if (steve.carrying) {
            apple.move(steve.x, steve.y);
          }
          if (dist(apple.x, apple.y, anthill.x, anthill.y) <=anthill.size) {
            steve.carrying = false;
            anthill.score += 1;
            step.reduce();
            apple = new Food();
          }
          if (dist(steve.x, steve.y, step.x+step.size/2, step.y+step.size/2) <= step.size/2) {
            step.enlarge();
          }
          if (step.size >= 150) {
            fill(256, 256, 256);
            text("Game Over", width/2 - 50, height/2);
            stop();
          }
        }
        class Ant {
            float x, y;
            float size;
            boolean carrying;
            Ant() {
              x = width/2;
              y = height/2;
              size = 40;
              carrying = false;
            }
          
            void display() {
              fill(0, 0, 0);
              circle (x, y, 18);
              circle (x+9, y+9, 15);
              circle (x+18, y+18, 18);
            }
            void catchFood(float foodX, float foodY) {
              if (dist(x, y, foodX, foodY) <= size) {
                carrying = true;
              }
            }
            void move() {
              x = mouseX;
              y = mouseY;
            }
          }
          class Food {
            float x, y;
            float easing;
            Food() {
              x = random(width);
              y = random(height);
              easing = 0.95;
            }
            void display() {
              noStroke();
              fill(0, 255, 0);
              circle (x, y, 24);
            }
            void move(float targetX, float targetY) {
              float dx = targetX - x;
              x += dx * easing;
              float dy = targetY - y;
              y += dy * easing;
            }
          }
          class Foot {
            float x, y;
            float size;
            float easing;
            Foot() {
              x = width/2;
              y = height/2;
              size = 80;
              easing = 0.05;
            }
          
            void display() {
              noFill();
              stroke(255, 255, 255);
              square(x, y, size);
            }
            void move(float targetX, float targetY) {
              float dx = targetX - x;
              x += dx * easing;
              float dy = targetY - y;
              //footstep variables
              y += dy * easing;
            }
            void enlarge() {
              size += 0.9;
            }
            void reduce() {
              size -= 0.9;
            }
          }
          class Hill {
            float x, y;
            float size;
            int score;
            Hill() {
              x = 607;
              y = 640;
              size = 60;
              score = 0;
            }
            void display() {
              fill(255, 255, 255);
              noStroke();
              triangle(550, 700, 632, 580, 714, 700);
            }
            void score() {
              fill(255, 255, 0);
              text(score, 430, 50);
              text("score:",350,50);    
              textSize(30);
            }
          }
      </code></pre>
        


    <div class="row">
        <div class="column">
          <img src="GameAntEscaping.png" style="width:70%">
          <figcaption>The image above shows first start the game, you need to use cursor to control the ant from a square which represents the human's footstep.</figcaption>
        </div>
        <div class="column">
          <img src="AntCatchFood.png" style="width:70%">
          <figcaption>The image above shows when the ant has catched the food (green dot), you need to use cursor to control the ant with the food escape from the square's chase and look for the anthill.</figcaption>
        </div>
        <div class="column">
          <img src="BacktoHill.png" style="width:70%">
          <figcaption>The image above shows when the ant bring the food back to anthill (white triangle), there would be new food generated and add 1 score to the scoreboard shows on the middle top.</figcaption>
        </div>
        <div class="column">
            <img src="GameOver.png" style="width:70%">
            <figcaption>The image above shows when the foot has stepped on the ant, it would enlarge the size of the step, and when the step size reach to 150 pixels, the game is over.</figcaption>
          </div>
      </div>

<h2 style="background-color:powderblue;"> Stephanie Houde and Charles Hill, What do Prototypes Prototype? </h2>
<p style="margin-right: 20%;"><span style="font-weight:bold">Quote 1:</span> "In fact, these three prototypes were developed almost in parallel. They were built by different design team members during the early stages of the project. No single prototype could have<br> 
    represented the design of the future artifact at that time. The evolving design was too fuzzy—existing mainly as a shared concept in the minds of the designers. There were also too many open and<br>  
    interdependent questions in every design dimension: role, look and feel, implementation."<br>
    Note: I think developing 3 prototypes as the same time is an essential way to achieve the final design goal. Since working separately would not limit the creativity and possibility of the design. For example, while designers defining the<br>   
    look and feel prototype, they would not consider about the implementation at this stage, and no-one would come to them and tell them this could not work, which make the prototypes close to the original design purpose. In this way, it is<br>   
    also convenient to organize and clarify the issues among 3 prototypes  in the final stage.<br>
    <br>
    <span style="font-weight:bold">Quote 2:</span> "They simulate what it would be like to look at and interact with, without necessarily investigating the role it would play in the user’s life or how it would be made to work."<br>
    Note: I believe how user would use and when they would use it should also be considered while developing the look and feel prototype. For example, if we are designing a product for elders or disabled, designer should keep in mind<br>   
    product’s role in developing the look and feel prototype. How could they interact with the product? How would they use the product? How often do they use? Where do they use at? Those questions should be answered while creating<br>   
    the look and feel of the design.<br>
    <br>
    <span style="font-weight:bold">Quote 3:</span> "Designers make implementation prototypes as experiments for themselves and the design team, to demonstrate to their organization the technical feasibility of the artifact, and to<br>   
    get feedback from users on performance issues."<br>
    Note: Once the designer has determined the time they plan to launch the product, or the time period the product would last in the future, the implementation prototype would not be that necessary. Since, if the prudct is designed<br>   
    to launch after 20 years from now, the product can be really conceptual, even some features and functions cannot be supported based on nowadays technology, but there would be a time in the future that the new inventions would<br>   
    help to build the product. The implementation prototype cannot only be tested by now but also can be considered in the future.</p>

<h2 style="background-color:powderblue;"> Project 2: Control System </h2>
<h3> Summary</h3>
<br>
<p style="margin-right: 20%;"> 
    For the project 2, I choose to keep working on the ant system concept and trying to develop it with the controller. Because I saw there could be some fun opportunities to imply the sensors and controllers into the project. <br>
    At first, I was imagine the controller can control the amount of the apple that the ant can find, or change the velocity of either ant or the footstep. However, I want to challenge myself to do a more complexed actions,<br> 
    so I used two controllers to control ant’s movement, and it turns out it is not that hard than I thought. Except of control ant’s movement, I used photocell to detect the real environment’s lightness and stimulate the real <br>
    light condition digitally, and when the environment is dark, the ant can easily escape from human’s chase. Compare to my first version if the system, I updated footstep and apple’s shape to make them look more real, and<br> 
    instead of let the ant and the step’s shape keep in the same direction while moving, I tried to using vector to change their heading directions while looking for the target. I am half there, It is successful to make the <br>
    ant’s head turns toward to the apple while it is moving, and when I apply the same code to the footstep, it doesn’t work, under the easing function, I cannot determine the previous positions of the step to calculate<br> 
    the vector and make it turns to the certain direction. For the physical controller, I used cardboard to make it more easier to hold and operate. For the future consideration, I want to play with the gradient background<br> 
    to simulate the real sunrise and sunset sky through the photocell sensor.
</p><br>
<h3>Code Example</h3>
    <pre><code>
        import processing.serial.*;

        Serial myConnection;
        String serialValue = "";
        float potX = 0;
        float potY = 0;
        float photo = 0;
        PVector dir;
        Hill anthill;
        Ant steve;
        Foot step;
        Food apple;
        
        void setup() {
          size(800, 800);
          steve = new Ant();
          step = new Foot();
          apple = new Food();
          anthill = new Hill();
          myConnection = new Serial(this, Serial.list()[2], 9600);
          myConnection.bufferUntil('\n');
        }
        void draw() {
          background (photo, photo, photo);
          anthill.score();
          anthill.display();
          apple.display();
          steve.move(potX,potY, apple.x,apple.y);
          steve.catchFood(apple.x, apple.y);
          steve.display();
          step.move(steve.x, steve.y);
          step.changeEasing(map(photo, 0, 255, 0, 1));
          step.display();
          if (steve.carrying) {
            //apple.changeEasing(map(photo,0,255,0,1));
            apple.move(steve.x, steve.y);
          }
          if (dist(apple.x, apple.y, anthill.x, anthill.y) <=anthill.size) {
            steve.carrying = false;
            anthill.score += 1;
            step.reduce();
            apple = new Food();
          }
          if (dist(steve.x, steve.y, step.x+step.size/2, step.y+step.size/2) <= step.size/2) {
            step.enlarge();
          }
          if (step.size >= step.critSize) {
            fill(99, 70, 77);
            text("Game Over", 350, 400);
            //stop();
          }
        }
        
        void serialEvent(Serial conn) {
          String fromSerial = conn.readString();
          if (fromSerial != null) {
            String[]data = split(fromSerial, ',');
            printArray(data);
            if (data.length ==3) {
              potX = float(data[0]);
              potX = map(potX, 0, 4095, 0, 765);
              potY = float(data[1]);
              potY = map(potY, 0, 4095, 0, 765);
              photo = float(data[2]);
              photo = map(photo, 0, 4095, 0, 255);
            }
          }
        }
        class Ant {
            PVector dir;
            float x, y;
            float size;
            boolean carrying;
            Ant() {
              x = 0;
              y = 0;
              size = 40;
              carrying = false;
            }
          
            void display() {
          
              fill(0, 0, 0);
              noStroke();
              ellipseMode(CENTER);
              rotate(dir.heading());
              ellipse (0, 0, 62, 32);
            }
            void catchFood(float foodX, float foodY) {
              if (dist(x, y, foodX, foodY) <= size) {
                carrying = true;
              }
            }
            void move(float x_, float y_, float ax, float ay) {
              x = x_;
              y = y_;
              dir = new PVector(x_, y_). sub(new PVector(ax, ay));
              dir.normalize();
              translate(x_, y_);
            }
          }class Food {
            float x, y;
            float adjEasing;
            float size;
            Food() {
              x = random(width);
              y = random(height);
              size = 30;
              adjEasing = 0.95;
            }
            void display() {
              noStroke();
              fill(163, 255, 33);
              ellipse(x, y, size, size + size * 0.3);
              ellipse(x + size/1.3, y, size, size + size * 0.3 );
              fill(245, 66, 72);
              ellipse(x + size/2-2, y + size/5-5, size/1.2, size/1.2 );
              stroke(38, 38, 38);
              curve(x + size/1.1-size/2.2, y + size/5-size/2, x + size/1.1-size/2.2, y + size/5-size/2, x + size/0.9-size/2.4, y - size/3-size/2.2, x + size/0.9-size/2.4, y - size/3-size/2.2);
            }
            void move(float targetX, float targetY) {
              float dx = targetX - x;
              x += dx * adjEasing;
              float dy = targetY - y;
              y += dy * adjEasing;
            }
          }class Hill {
            float x, y;
            float size;
            int score;
            Hill() {
              x = 607;
              y = 640;
              size = 60;
              score = 0;
            }
            void display() {
              fill(252, 186, 3);
              noStroke();
              triangle(550, 700, 632, 580, 714, 700);
            }
            void score() {
              fill(99, 70, 77);
              text(score, 430, 50);
              text("score:",350,50);    
              textSize(30);
            }
          }       
</code></pre>
<br>
<h2 style="background-color:powderblue;"> Programming Design Systems </h2>
<p style="margin-right: 20%;"><span style="font-weight:bold">Quote 1:</span>
"By increasing the size of important shapes and decreasing the size of less significant shapes, you can bring clarity to a design."
<br>
Note: Be aware of applying the principles of the hierarchy is essential in the system design. And using the size to differentiate the importance of the imformation is a simple but powerful tool. Each information and sections' porpotion in the screen<br>
could simply guide people's reading order and attract their attention into something that designer intends them to notice.
<br><br>
<span style="font-weight:bold">Quote 2:</span>
"The way these grid systems are applied is essentially no different from how printmakers used them centuries ago, but one could argue that there is an even greater need for them today with the explosion of digital content: Digital<br> 
design products must adapt to different screen sizes and show dynamic content, so there is no true original design. This forces designers to think systematically about visual layout."
<br>
Note: I enjoy using grid system a lot especially when it comes to design for multi screens. The grid system would help designer to follow the visual rules and display bunch of informations in a organized and logical way. It is really<br> 
helpful while designing for small digital screens, everything can be simply arranged in each grid without causing any visual confusions but you still got varities to play with inside the small grids.
<br><br>
<span style="font-weight:bold">Quote 3:</span>
"When designers learn to not only think systematically about the design process, but also to implement those systems in software, they can build things that were not possible before."
<br>
Note: It is smart to use programming to create artworks, it would not only save much time and efforts on actually making the art pieces, but it also would systematically create something that is unpredictable. While designers are<br>  
thinking systematically of the design process, they can also get inspired of how the programm works behind the screen.
<br> <br> 

<h2 style="background-color:powderblue;"> Radical Technologies Reading Response </h2>
<p style="margin-right: 20%;"><span style="font-weight:bold">Quote 1:</span>
"device manufacturers—aren’t incentivized to fix them, while the end user doesn’t have the expertise to do so."
<br>
Note: Set the standards of a safety boundary would be tricky, it is hard to identify and balance the informations that users want the smart device to know or hear and their personal privacy that users do not want their devices to know at all.<br> 
It is hard to define what are the privacies that user are likely to be protected, since users are enjoy the convenience that the technology brings to them with a little sacrifice of their “privacy”, but at the same time, they are scarred of <br>
how unethical that the technologiesy secretly stole their personal informations and watch them all the time. I think, as the technology continuously develops in the future and provides more surprisingly convincing service to the public by <br>
keep collecting users information to fill the database, there will be a point that either public would realize that it is worthy of their sacrifices, or users would not trust the technology anymore. Building the trust with the users is essential<br>
for both company and designers to consider about.
<br><br>
<span style="font-weight:bold">Quote 2:</span>
"At present, the internet of things is the most tangible material manifestation of a desire to measure and control the world around us. But as an apparatus of capture, it is merely means to an end. The end remains the quantification of the processes<br> 
of life at every scale; their transformation into digital data; and the use of that data for analysis, the development of projective simulation and the training of machine- learning algorithms. It behooves us to spend some time thinking about what<br> 
comes along for the ride, every time we invoke this complex of ideas, to consider where it might have come from and what kind of world it is suggesting we live in."
<br>
Note: I agree that the internet of things should always be a tool of collecting and organizing the data instead of being a tool that truly discover the user needs and goals. In the mathematics world, we can fully trust the result that the algorithm<br>  
and data analyzing brings to us, but in human civilization, and the society, we should not use it as the only reference to make the decisions. As the designer, we should always think about the consequence of those data could bring to us, and not only<br>  
listen to its suggestions and let it direct how we are going to live. There should always be human interactions involved in any decisions about the society. The internet of things should not be used as only reference while designing the world.
<br><br>
<span style="font-weight:bold">Quote 3:</span>
"the internet of things is a sprawling and complex domain of possibility, and it would be foolish to avoid investigating it energetically and in good faith. But we would be wise to approach that investigation with an unusually strong leavening of<br>  
skepticism, and in particular to resist its attempts to gather data regarding ourselves, our whereabouts, our activities and our affiliations, whatever the blandishments of ease, convenience or self-mastery on offer."
<br> 
Note: To achieve the goal that fully use the advantage of applying the internet of things into our daily life and provide much convenient service to the public, the government and capitalist should not hide the truth under their algorithmic database,<br>  
and the users should also acknowledge about the importance of protecting theirselves privacy, and how they should be aware of it. Also, the designers should aware about and consider the long-term benfits of using the data analysis, rather than taking<br> 
the shortcuts and letting artificial intelligence algorithms take over their work
</html>